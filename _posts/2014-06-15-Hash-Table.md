---
layout: post
title: "Hash Table"
description: "Algorithm"
category: Algorithm 
tags: [Algorithm]
---
{% include JB/setup %}

#哈希表
- - -
## 直接寻址表
1. 当关键字的全局域较小，而且每个key都不相同时，建立一个一一对应的映射，其操作均为O(1)的时间复杂度。

2. 存在一个问题，那就是当关键字很多时，该方法无法应用。

##哈希表
1. 为了解决全局域很大的情况，利用hash函数，根据key计算value（value=h(k)）。

2. 该方法同样存在一个问题，那就是存在**冲突**，即，两个key可能映射到同一个槽里（h(k1) = h(k2)).

3. 理想的解决上述问题的方法是，尽可能的选择合适的hash函数来避免冲突，但是当key NO.大于value NO.时，必然存在冲突。此时有两种方法解决此问题：一、链接法，即将hash到同一个槽的所有元素都放在一个链表里；二、开放寻址法。

4. 当hash table T的装载因子 α = n/m，不是太大时，hash表可以有常数级的操作时间。

##哈希函数
1. 什么是好的哈希函数？ 满足一下两个假设：一.每个关键字都等可能的散列到m个槽位中的任一个，并且与其他关键字散列到哪个槽位无关。

2. 除法散列法：
	- h(k) = k mod m
	- m的选取需要注意：首先m不能太小；其次，m不应该是2的幂，假设m = 2^p，则h(k)就是k的p个最低位数字，如果p个最低位的排列不是等可能的，则不是好的hash；最后，m最好选择一个不太接近2的素数。

3. 乘法散列表：
	- h(k) = (A*k mod 2^w) rsh (w-r) 其中，m = 2^r ,我们的电脑是k位的，而且A是一个奇数，2^(w-1) < A < 2^w
	- A 不要太靠近2^(w-1)和 2^w
	- multiplication modulo 2^w is faster than division
	- rsh is fast
	- 可以把该算法看成是一个转盘，A*k即是转了k圈，然后通过mod和rsh来使其落在m个格子里

4. 开放寻址法
	- 在开放寻址法中，所有的元素都存放在散列表里。为了插入一个数据，需要通过一个探查序列（probe）找到一个合适的空槽来放置待插入的数据。
	- 计算探查序列的方法：
		- **线性探查**
			给定一个普通的散列函数 $$$h'(k)$$$,则线性探查法采用的散列函数为：
            $$$h(k,i)=(h'(k)+i)~ mod ~m$$$
            线性探查方法较易实现，但它容易发生一次集群，即随着连续被占用的槽不断增加，平均查找时间也随之不断增加。
        - **双重探查**
			$$$h(k,i)=(h_1(k)+ih_2(k))~mod~m$$$
           为了查找整个散列表，值$$$h_2(k)$$$必须要与表的大小m互素。
           散列表越满，其探查的效率越低。预期的探查次数小于1/(1-α)
       
       
##哈希进阶
1. 哈希有个缺点，即是，不论你选用何种类型的hash函数，总可以找到一组key，使其全部hash到同一个slot里面。 解决方法:choose the hash function at random, independently of the keys.

2. 设H是一组有限散列函数，它将给定的关键字全域U映射到{0,1，....m-1}中，这样的一个函数组称为全域的。

3. 如果从H中随机选取一个散列函数，当关键字k不等于l时，两者发生冲突的概率不大于1/m。


##完全哈希
1. Given n keys, construct a static hash table of size m = O(n)， search hash tables O(1) in the worst case.

2. Idea： 采用两级的散列方法来设计完全散列方案，在每级上都使用全域散列。 其中：第一级:同带链表的的散列表基本上是一样的，利用从某一全域散列函数集中仔细挑选出的一个散列函数h，将n个关键字散列到m个槽中。 第二级：不是将散列到槽j的所以关键字建立一个链表，而是利用精心挑选的散列函数 $$$h_j$$$，进行二次散列，可以确保第二级上不会出现冲突（为了满足该性质，需要让散列表$$$S_j$$$的大小$$$m_j$$$为散列到槽j中关键字数$$$n_j$$$的平方）。










            
            